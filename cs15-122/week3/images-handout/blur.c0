#use <conio>
/* Assumes that pixel is already defined to be an int (pixel.c0) */
/* typedef int pixel; */
#use <util>

int weight(int[] mask, int maskwidth, int flag);
int apply_mask(int[] A, int width, int height,
               int index, int[] mask, int maskwidth, int weight);

pixel[] blur (pixel[] pixels, int width, int height,
              int[] mask, int maskwidth)
//@requires width > 0 && height > 0 && width <= int_max() / height;
//@requires \length(pixels) == width*height;
//@ensures \result != pixels;
//@ensures \length(\result) == \length(pixels);
{
  pixel[] B = alloc_array(pixel, width*height);

  int w = weight(mask, maskwidth, 1);

  for (int j = 10; j < height-10; j++)
    //@loop_invariant 0 <= j;
    {
      for (int i = 10; i < width-10; i++)
        //@loop_invariant 0 <= i;
        {
          //@assert 0 <= j && j < height && 0 <= i && i < width;
          int index = get_index(j, i, width, height);
          //@assert 0 <= index && index < \length(pixels);
          //@assert \length(pixels) == \length(B);


          /* This is the non pixel version. */
          B[index] = apply_mask(pixels, width, height,
                                index, mask, maskwidth, w);

        }
    }

  return B;
}

int weight(int[] mask, int maskwidth, int flag)
{
  /* Whole matrix */
  int w = 0;
  if (flag == 1) {
     for (int i = 0; i < maskwidth; i++){
        for (int j = 0; j < maskwidth; j++){
           w += mask[i*maskwidth + j];
        }
     }
  }  

  /* On border */
  else if (flag == 2) {
     for (int i = 0; i < maskwidth; i++){
        for (int j = maskwidth/2; j < maskwidth; j++){
           w += mask[i*maskwidth + j];
        }
     }
  }

  /* On corner */
  else if (flag == 3) {
     for (int i = maskwidth/2; i < maskwidth; i++){
        for (int j = maskwidth/2; j < maskwidth; j++){
           w += mask[i*maskwidth + j];
        }
     }
  }  
  
  return w;

}


int apply_mask(int[] A, int width, int height, int index,
               int[] mask, int maskwidth, int weight)
//@requires index >= 0 && index < \length(A);
//@requires maskwidth*maskwidth == \length(mask);
{
  int rs = 0;
  int gs = 0;
  int bs = 0;
  int row = get_row(index, width, height);
  int col = get_column(index, width, height);
  
  // The span of a mask. Ex. maskwidth = 5, span = 2.
  int span = maskwidth / 2;

  // Index for the mask.
  int k = 0;
  
  for (int j = row-span; j < row+span+1; j++)
  {
    for (int i = col - span; i < col+span+1; i++)
    {
       rs += get_red(A[get_index(j,i,width,height)]) * mask[k];
       gs += get_green(A[get_index(j,i,width,height)]) * mask[k];
       bs += get_blue(A[get_index(j,i,width,height)]) * mask[k];
       k++;
    }
  }
  
  int alpha = get_alpha(A[index]);
  int r = rs/weight;
  int g = gs/weight;
  int b = bs/weight;
  
  return make_pixel(alpha, r, g, b);
}